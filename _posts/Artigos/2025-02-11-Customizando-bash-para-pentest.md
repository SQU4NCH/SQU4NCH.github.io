---
title: "Customizando o bash para pentest"
classes: wide
header:
  teaser: /assets/images/so/01.jpg
  overlay_image: /assets/images/so/01.jpg
  overlay_filter: 0.5
ribbon: DarkSlateGray
excerpt: "Nessa postagem mostro algumas dicas de customização do bash para pentest afim de otimizar o ambiente de testes"
description: "Nessa postagem mostro algumas dicas de customização do bash para pentest afim de otimizar o ambiente de testes"
categories:
  - Bash
tags:
  - Sistemas Operacionais
toc: true
toc_sticky: true
toc_label: "Sumário"
toc_icon: "terminal"
---

Recentemente terminei a leitura do livro Black Hat Bash, o livro é bem interessante e trás vários insights do uso do bash durante um pentest e até em operações de Red Team. Ele passa por todas as fases do teste, começando na coleta de informações e vai até o bypass de mecanismos de defesa.

Um assunto que achei muito interessante foi a customização do bash para pentest, a ideia é otimizar o ambiente para deixar o trabalho mais fácil durante o teste. Então, resolvi trazer algumas dessas dicas que, mesmo parecendo simples, quando combinadas podem criar um ambiente poderoso para testes.
## Colocando scripts em Paths pesquisáveis

O bash procura por programas nos diretórios que estão definidos na variável de ambiente PATH. Os comandos de sistema, por exemplo, estão localizados nos diretórios que fazem parte do PATH e por é isso que eles estão disponíveis independente do lugar no sistema onde você está.

Para ver o seu PATH, execute o seguinte comando:

```
$ echo $PATH

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

Quando criar um novo script, você pode adicionar ele no diretório */usr/local/bin*, que como pode ser visto acima, faz parte do PATH. Dessa forma, você pode chamar o script passando diretamente o nome dele, sem precisar passar o caminho completo ou estar no mesmo diretório.
## Encurtando comandos com Aliases

Sempre que perceber que está usando um comando longo com frequência, você pode usar um alias para criar um nome curto e customizado que pode te poupar tempo quando você precisar executar esse comando.

Por exemplo, imagine que você usa com frequência o nmap usando parâmetros para fazer um scan em todas as portas de um determinado IP.

```
nmap -vv -T4 -p- -sV --max-retries 5 10.10.10.10
```

Esse comando pode ser um pouco difícil de lembrar. Com um alias podemos deixar ele mais acessível para usar na linha de comando ou em um script. Podemos passar esse comando para o alias *snmap*:

```
$ alias snmap="nmap -vv -T4 -p- -sV --max-retries 5"
```

Agora podemos rodar esse comando passando somente o alias:

```
$ snmap 10.10.10.10
Starting Nmap ( https://nmap.org ) at 02-21 22:32 EST
--snip-- 
PORT STATE SERVICE 
631/tcp open ipp
```

Aliases não são permanentes, mas eles podem ser. Essa é a próxima dica.
## Customizando o ~/.bashrc Profile

Podemos usar o arquivo ~/.bashrc para carregar funções, variáveis ​​e praticamente qualquer outro código bash personalizado que desejarmos em uma nova sessão bash. Por exemplo, podemos criar variáveis ​​contendo informações que precisaremos usar com frequência, como o endereço IP de um host que estamos testando. 

Para isso, podemos acrescentar as seguintes informações ao final do arquivo ~/.bashrc, por exemplo:

```
VULN_HOST=1.0.0.22 
VULN_ROUTER=10.0.0.254 

alias snmap="nmap -vv -T4 -p- -sV --max-retries 5"
```

Essas linhas definem algumas variáveis ​​personalizadas e salvam nosso comando nmap com alias.

Na próxima vez que você abrir um terminal, você poderá acessar esses valores usando o comando source para reimportar o arquivo ~/.bashrc:

```
$ source ~/.bashrc 

$ echo ${VULN_HOST} 
10.0.0.22 

$ echo ${VULN_ROUTER} 
10.0.0.254
```

Agora você pode usar essas variáveis ​​mesmo depois de fechar o terminal e iniciar uma nova sessão.
## Importando scripts customizados

Outra maneira de criar mudanças na sua sessão bash é criar um script dedicado que contenha personalizações relacionadas a pentesting e então fazer com que o arquivo ~/.bashrc o importe usando o comando source. 

Para isso, crie um arquivo ~/.pentest.sh, por exemplo, contendo sua nova lógica e então adicione o seguinte comando no final do arquivo ~/.bashrc para importar pentest.sh:

```
source ~/.pentest.sh
```
## Gravando as atividades da sessão

Um pentest geralmente envolve ter dezenas de terminais abertos simultaneamente, todos executando muitas ferramentas que podem produzir muita saída. Quando encontramos algo de interesse, podemos precisar de parte dessa saída como evidência para mais tarde. Para evitar perder o controle de uma informação importante, podemos usar um bash inteligente. 

O seguinte script nos permite capturar a atividade da sessão do terminal. A ideia é carregar um pequeno script bash que usa o comando script para salvar cada sessão em um arquivo para inspeção posterior.

```bash
#!/bin/bash 

FILENAME=$(date +%m_%d_%Y_%H:%M:%S).log 
if [[ ! -d ~/sessions ]]; 
then 
	mkdir ~/sessions 
fi 

# Starting a script session 
if [[ -z $SCRIPT ]]; 
then 
	export SCRIPT="/home/kali/sessions/${FILENAME}" 
	script -q -f "${SCRIPT}" 
fi
```

Carregando esse script no ~/.bashrc, como mostrado anteriormente, o script criará o diretório ~/sessions, contendo cada captura de sessão de terminal em um arquivo separado. A gravação para quando você digita exit no terminal ou fecha a janela do terminal.
## Conclusão

Como mencionei no inicio, essas são dicas simples mas quando combinadas podem ajudar bastante no dia a dia, ou até mesmo durante alguma certificação. 

Espero que esses insights possam te ajudar ajudar de alguma forma, ou gerar ideias para que você possa criar outras automações.
## Referências

* FARHI, Dolev; ALEKS, Nick. Black Hat Bash: Creative Scripting for Hackers and Pentesters. San Francisco: No Starch Press, 2024.
